# +Load 和 +Initialize 用法

这里只讲结果,具体的原理请参考文章末尾的文章！

### +Load 方法 在main函数执行之前被调用

因为是编译的时候被调用,因此 只要类实现了+load方法都会被调用。不同类或者有继承关系的类中+load的调用顺序是由文件的编译顺序决定的。

那么怎样判断继承关系中+load方法被调用的顺序呢？

在同一个文件中声明两个有继承关系的类 查看这两个类的+load方法调用顺序！

分类和原类中的执行顺序呢？

如果分类中也实现了这个方法，那么父类分类和原类的方法都会被调用不存在覆盖的情况。分类是最后被调用(这里我们可以联想 我们在做方法交换的时候的操作,这就证明分类最后被执行)


### +Initializez 在类第一次被使用的时候调用

类第一次被使用的时候调用,这就说明如果在一次程序运行期间，某一个类没有被使用。那么这个类的Initializez是不会被调用的。

父类和子类的调用顺序是先调用父类后调用子类！且如果子类没有实现 那么子类会沿用父类的实现(通过调用父类的方法)。

那么这就有一个问题，如果一个类存在多个子类，如果子类没有实现这个方法，那么父类中的方法会被调用多次。

如果分类中也实现了这个方法，那么原来类中的方法将会被覆盖。但是并不影响父类的调用。因此如果实现了这个子类的分类那么调用顺序为：父类->分类


### 总结


  |+load	| +initialize
-------|------|-------------
调用时机	| 被添加到 runtime 时	| 收到第一条消息前，可能永远不调用
调用顺序	| 父类->子类->分类	| 父类->子类
调用次数	| 1次	|多次
是否需要显式调用父类实现 |	否 |	否
是否沿用父类的实现 |	否 |	是
分类中的实现 |	类和分类都执行 |	覆盖类中的方法，只执行分类的实现

## 参考文章

[Objective-C +load vs +initialize](http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/)

